# Changelog

Все значимые изменения в этом проекте будут документированы в этом файле.

## [Unreleased]

### Планируется
- Распределенный кэш с консистентным хешированием
- Redis адаптер
- Memcached адаптер
- Prometheus метрики
- Шардирование для уменьшения contention
- Сжатие данных
- Персистентность на диск

## [1.0.0] - 2025.08.14

### Добавлено
- Базовый интерфейс `Cache` с универсальными методами
- Три реализации in-memory кэша:
  - `SimpleCache` - базовый кэш без политик вытеснения
  - `LRUCache` - кэш с политикой Least Recently Used
  - `LFUCache` - кэш с политикой Least Frequently Used
- Поддержка TTL (Time To Live) для автоматического истечения элементов
- Фоновая очистка истекших элементов
- Детальная статистика производительности:
  - Количество попаданий и промахов
  - Процент попаданий (hit rate)
  - Количество ключей и вытеснений
- Потокобезопасные операции с использованием `sync.RWMutex`
- Внутренние утилиты:
  - Хеш функции для шардирования
  - Система метрик с детальной статистикой
- Комплексное тестирование:
  - Unit тесты для всех реализаций
  - Тесты потокобезопасности
  - Бенчмарки производительности
  - Тесты безопасности данных
- Примеры использования:
  - Базовое использование библиотеки
  - Сравнение производительности реализаций
  - Реальные сценарии (кэширование пользователей, API, сессий)
- Полная документация с примерами кода

### Производительность
- `SimpleCache`: ~2.0M ops/sec (Set), ~4.7M ops/sec (Get)
- `LRUCache`: ~2.3M ops/sec (Set), ~4.7M ops/sec (Get)
- `LFUCache`: ~2.0M ops/sec (Set), ~4.9M ops/sec (Get)

### Техническая реализация
- Двусвязный список для эффективной LRU реализации
- Atomic операции для статистики без блокировок
- Копирование данных для предотвращения внешних изменений
- Graceful shutdown с корректным завершением горутин
- Паттерн double-checked locking для проверки истечения TTL

### Обновление до v1.0.0

Это первый стабильный релиз, поэтому миграции не требуется.

Пример использования:

```go
// Вместо создания через конструкторы
cache := memory.NewLRU(1000)
defer cache.Close()

// Базовые операции
cache.Set("key", []byte("value"))
value, exists := cache.Get("key")
cache.Delete("key")

// С TTL
cache.SetWithTTL("temp", []byte("data"), 5*time.Minute)

// Статистика
stats := cache.Stats()
fmt.Printf("Hit rate: %.2f%%", stats.HitRate)
```

## Совместимость

### Go версии
- Тестировалось на версии: Go 1.22.5

### v1.0.0
- LFU кэш показывает низкую производительность в смешанном режиме доступа (~34K ops/sec) из-за неоптимального алгоритма поиска минимальной частоты
- Отсутствует автоматическое сжатие map при большом количестве удалений
